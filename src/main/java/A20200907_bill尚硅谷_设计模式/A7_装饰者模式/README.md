
## 1.介绍

    1.装饰者模式定义：
        1)装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)
        2)这里提到的动态的将新功能附加到对象和 ocp 原则，在后面的应用实例上会以代码的形式体现，请同学们注意体会。
    2.原理
        1)装饰者模式就像打包一个快递
            主体：比如：陶瓷、衣服 (Component) //  被装饰者
            包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)
        2)Component 主体：比如类似前面的 Drink
        3)ConcreteComponent 和 Decorator
            ConcreteComponent：具体的主体， 比如前面的各个单品咖啡
            Decorator: 装饰者，比如各调料.
    
    
## 2.使用:可多可单，可组合可不组合 
    
    1.示例：星巴克咖啡订单项目（咖啡馆）：
        1)咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)
        2)调料：Milk、Soy(豆浆)、Chocolate
        3)要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便
        4)使用 OO 的来计算不同种类咖啡的费用:  客户可以点单品咖啡，也可以单品咖啡+调料组合。
    2.较差解决方案：
        列出所有品类组合处理：例如:只是咖啡-Espresso,...，只是调料：-milk... ,两者组合：Milk+Espresso,Milk+Espresso+Soy...
        抽象类 Drink { cost(){}},以上的作为实现类
        分析：那么新加一种咖啡时，咖啡组合情况就会有很多情况，相对应的类拓展就会很多-类爆炸
    3.优化后的方案01：
        将调料内置到Drink中，不会造成类数量过多，例如
        Drink {
            milk
            Soy
            Chocolate
            属性的set/get
            cost(){}
        }
        Espresso implements Drink{
            cost(){}
        }
        分析：
            1.可以控制类的数量，不至于造成很多的类
            2.在增加或者删除调料种类时，代码的维护量很大
            3.考虑到用户可以添加多份 调料时，可以将 hasMilk 返回一个对应 int
    4.装饰者模式：

## 3.自己分析的问题
    
    1.点餐问题：吃的+喝的可以自由组合
    2.装饰者模式：
        
    
## 3.使用场景
    
    java中的IO相关的
    
